1	应用背景
在计算机系统中，内存资源是宝贵又有限的，如果进程发生了内存泄漏，会使内存资源不断地消耗，导致系统性能下降，程序运行速度变慢，无法及时响应用户的输入输出请求。对于我司嵌入式产品，物理内存的大小要比PC机中的内存小得多，通常在几十到两百兆之间，比如我司IPC123-EN(S2平台)实际总内存只有152M。鉴于这种情况，在软件发布前，对于程序进行全面的内存泄漏检测很有必要。而Valgrind作为一个免费且优秀的工具包，检测内存问题是其一个最为重要的功能。
2	Valgrind 工具使用
  Valgrind支持很多工具:memcheck，addrcheck，cachegrind，Massif，helgrind和Callgrind等。在运行Valgrind时，你必须指明想用的工具,如果省略工具名，默认运行memcheck。
2.1	Memcheck
2.1.1	Memcheck介绍
memcheck探测程序中内存管理存在的问题。它检查所有对内存的读/写操作，并截取所有的malloc/new/free/delete调用。因此memcheck工具能够探测到以下问题：
1）使用未初始化的内存
2）读/写已经被释放的内存
3）读/写内存越界
4）读/写不恰当的内存栈空间
5）内存泄漏
6）使用malloc/new/new[]和free/delete/delete[]不匹配。
7）src和dst的重叠
2.1.2	用法举例
首先，举个简单的例子，给大家一个直观的印象：
被测程序的mem_leak.c如下：
 
Step 1：即前提条件，安装valgrind。
1） 到www.valgrind.org下载最新版valgrind-3.10.1.tar.bz2
2） 解压安装包：tar –jxvf valgrind-3.10.1.tar.bz2
3） 解压后生成目录valgrind-3.10.1
4） cd valgrind-3.10.1
5） 运行./autogen.sh设置环境
6） ./configure;配置Valgrind，生成MakeFile文件，具体参数信息详见INSTALL文件。一般只需要设置--prefix=/where/you/want/it/installed
7）Make，编译Valgrind
8）make install，安装Valgrind
Step2：编译。
gcc –g –o mem_leak memleak.c
注：1）在编译程序时最好打开调试模式，比如gcc编译器需加上-g选项。打开调试选项进行编译后再用valgrind检查，valgrind将给出较为详细的报告，比如具体到哪一行代码出现了内存泄漏。
2）当检查C++程序时，还应考虑加上另一个选项-fno-inline。它会使函数调用链很清晰。
Step3：执行valgrind。
Valgrind --tool=memcheck --track-fds=yes --log-file=‘log.txt’ --leak-check=full ./mem_leak
注：1）选项--tool=<name>:指明valgrind的工具，默认为memcheck。
2）选项--track-fds=<yes|no>:是否跟踪打开的文件描述符,默认为no。
3）选项--log-file=<file>:输出log信息到文件file中。
4）选项--leak-check=<no|summary|full>:反馈信息的详尽程度。Summay只反馈一些总结信息，full将输出所有的links，也就是定位到每一个malloc/fee。默认为summary。
5）这里valgrind已加入到环境变量中，如果未加入到环境变量中，需指明该工具的路径。
Step4: 分析报告
执行完后我们可以看到生成的报告log.txt,如附件所示。
 
从报告中，我们可以看到几乎所有的内存泄漏、资源泄漏的信息。下面我们分别进行分析：
 
所有行，前面的3142是指程序运行时的进程号；
第1行，指出tool的名字；
第4行，指出执行的被测程序的名字；
第5行，父进程号；
第8-28行，这里检测到了文件指针资源的泄漏，提示有4个文件描述符在退出时仍是打开的。描述符0,1,2无需关心，通过报告可以发现我们的被测程序mem_leak.c中第12行，打开的文件描述符没有关闭。
 

第31-33行，堆信息的总结:一共调用了4次alloc，0次free；
第35-38行，检测到一个字节的内存泄漏，在mem_leak.c第7行处；
第40-50行，内存泄漏总结：直接泄漏1字节，间接泄漏0，可能泄漏0.
2.1.3	小结
这里举得是一个非常简单的例子，只是为了方便演示valgrind中memcheck工具的使用方法。对于很大代码量的程序，申请的内存可能被传来传去，用valgrind检测可以很大程度上避免内存泄漏。对于其跟多的用法，可以加“-h”或“--help”查看学习。
2.2	其它工具介绍
2.2.1	Callgrind 
和gprof类似的分析工具，但它对程序的运行观察更是入微，能给我们提供更多的信息。和gprof不同，它不需要在编译源代码时附加特殊选项，但加上调试选项是推荐的。Callgrind收集程序运行时的一些数据，建立函数调用关系图，还可以有选择地进行cache模拟。在运行结束时，它会把分析数据写入一个文件。callgrind_annotate可以把这个文件的内容转化成可读的形式。 
2.2.2	Cachegrind 
Cache分析器，它模拟CPU中的一级缓存I1，Dl和二级缓存，能够精确地指出程序中cache的丢失和命中。如果需要，它还能够为我们提供cache丢失次数，内存引用次数，以及每行代码，每个函数，每个模块，整个程序产生的指令数。这对优化程序有很大的帮助。 
2.2.3	Helgrind 
它主要用来检查多线程程序中出现的竞争问题。Helgrind寻找内存中被多个线程访问，而又没有一贯加锁的区域，这些区域往往是线程之间失去同步的地方，而且会导致难以发掘的错误。Helgrind实现了名为“Eraser”的竞争检测算法，并做了进一步改进，减少了报告错误的次数。不过，Helgrind仍然处于实验阶段。 
2.2.4	Massif 
堆栈分析器，它能测量程序在堆栈中使用了多少内存，告诉我们堆块，堆管理块和栈的大小。Massif能帮助我们减少内存的使用，在带有虚拟内存的现代系统中，它还能够加速我们程序的运行，减少程序停留在交换区中的几率。 
   此外，lackey和nulgrind也会提供。Lackey是小型工具，很少用到；Nulgrind只是为开发者展示如何创建一个工具。我们就不做介绍了。 
3	项目实践
3.1	实例：对sysdbg组件进行检测
系统部测试组要对所有交付组件进行测试，为了保证组件内存方面的性能，组内成员在通过一番探索实践后，选用Valgrind工具集对各个平台的交付组件进行检测。
这里对S2平台的sysdbg组件进行检测，作为示例。
Step1：在程序执行的设备上安装Valgrind工具；
S2设备架构为arm-linux，下载和设备架构匹配的Valgrind软件版本，上传到设备上，这里上传路径为/tmp；
Step2：编译，上传；
1）	编译组件库：Clone组件对应分支的代码，在编译脚本中加上-g参数，编译组件库，最后生成sysdbg.a 的调试版本；
2）	编译可执行的测试程序：链接上面编译生成的debug版本的sysdbg.a，编译生成s2_v1.1_sysdbg;
3）	将s2_v1.1_sysdbg上传到运行设备上；
Step3：在设备上执行valgrind；
/tmp/valgrind/bin/valgrind --tool=memcheck --leak-check=full --log-file='log.txt' ./s2_v1.1_sysdbg
Step4：分析报告，报告如附件；
 
 
内存泄漏情况：直接和间接泄漏为0，可能泄漏为1处。
3.2	Valgrind自动化测试框架介绍
为了提供效率，valgrind检测组件的全过程，我们组对其进行了自动化的探索和实现。通过python程序，目前实现了自动上传、自动执行、自动下载报告，并可在jenkens上将报告解析成表格形式。
具体步骤参考李展鹏的文档：《内存泄漏valgrind使用指导》。
4	总结
根据实际工作需要，选择valgrind工具进行代码的内存问题检测。本文举例并结合工作实践，对工具使用方法和注意事项进行详细阐述，目前Valgrind自动化测试框架只覆盖了S2平台的部分组件，后续会继续完善，提供平台和组件的覆盖度。
